// Wright-Fisher simulation of a single population with fixed population size where fitness is determined by temperature that can fluctuate generation-to-generation or within generation as well.

// At each reproductive cycle (there are a fixed number of reproductive cycles per generation), fitness is determined by thermal performance curve (TPC) and current temperature (T). TPC is solely determined by default TPC and mutations in the QTN region (i.e. no thermal acclimation). Current temperature is a random number sampled from a normal distribution where the distribution itself can vary macroscopically seasonally, for instance. In the case for no-recovery model, fitness at each reproductive cycle also depends on whether the organism experienced overheating before that cycle (i.e. if there was T > CTmax). The average of fitness over all reproductive cycles is used for binomial sampling (typical of WF model) to create the next generation population.

// When running this script in command line, one can modify any parameter value listed in "params". If not modified, the script will run with default values defined as in this script.

// This script outputs a log file that records various phenotypic measures over multiple generations and a tree-sequence file that contains "params" as metadata.


initialize() {
	initializeTreeSeq();
	// environmental variance
	defineConstant("ENV_var", 0.5);
	// Two kinds of quantitative trait mutations (QTNs) are simulated. 
	defineConstant("QTN_mean", c(0,0));
	defineConstant("QTN_var", c(0.05, 0.05));
	// QTN1 (B) has effect size sampled from a normal distribution with mean and standard deviation defined by the first entry of QTN_mean and QTN_var
	// Note that 'sqrt' used because "n" uses standard deviation not variance
	initializeMutationType("m2", 0.5, "n", QTN_mean[0], sqrt(QTN_var[0]));
	// Mutations should have effect even after fixation, so we set convertToSubstition to False.  
	m2.convertToSubstitution = F;
	// Color QTN1 red in SLiMgui
	m2.color = "red";
	
	// QTN2 (CTmin) has effect size sampled from a normal distribution with mean and standard deviation defined by the second entry of QTN_mean and QTN_var
	// Note that 'sqrt' used because "n" uses standard deviation not variance
	initializeMutationType("m3", 0.5, "n", QTN_mean[1], sqrt(QTN_var[1])); 
	m3.convertToSubstitution = F;
	// QTN2 will look blue in SLiMgui
	m3.color = "blue";
	// Middle section of the genome is our "QTN region", where each mutation has a 50-50 chance of either being a QTN for CTmin or B.
	initializeGenomicElementType("g2", c(m2, m3), c(0.5, 0.5));
	initializeGenomicElement(g2, 20001, 80000);
	// Now we will define parameters that can be modified if this script is run on command line. For instance, "slim -d T_mean=20 -d T_amp=0 single_pop_no_acclimation.slim" will modify T_mean and T_amp according to your inputs while leaving the rest of the params as default. 
	// Let's make a dictionary of all default values
	params = Dictionary(
		"seed", getSeed(),
		"RUNTIME", 60000, // number of generations (-1) to simulate
		"BURNIN", 5000, // QTN has no effect on fitness for the first BURNIN generations. This is to accumulate some amount of genetic variation before non-neutral dynamics.
		"N_POP", 5000, // population size
		"MU", 1e-7, // mutation rate per bp
		"Recovery", T, // T = recovery model, F = no-recovery model
		"T_same_for_all_individuals", F, // if true, everyone at the same reproductive cycle experiences the same temperature. If False, each individual experience slightly different temperature (difference would depend on how big sigma_T_within_gen is).

		"T_mean", 15, // yearly average temperature
		"T_amp", 0, // sets up the amplitude of seasonal sinusoidal fluctuation of temperature.
		"Num_gen_per_year", 24, // length of period of the sine function (irrelevant if T_amp=0, i.e. no season)
		"sigma_T_across_gen", 0, // random noise added to temp at each gen
		"sigma_T_within_gen", 0, // standard deviation of temperature distribution within generation
		"n_r", 10, // number of reproductive cycles per generation
		"B_WT", 30, // default B (WT stands for wild-type since this is B if there is no QTN mutations)
		"CTmin_WT", 0, // default CTmin
		
		// params for fitness components in TPC model. 
		"B_critical", 40, 
		"DeltaB", 2,
		"CTmin_critical", 0,
		"DeltaCTmin", 2,
		"CTmax_critical", 40,
		"DeltaCTmax", 0.2,
		"num_linkage_groups", 12,
		"LOGINTERVAL", 10
	); 
	for (k in params.allKeys) {
		// if the parameter is not modified with -d, get default value from dictionary.
		if (!exists(k)) {
			defineConstant(k, params.getValue(k));		
		}
		// if you used -d, replace value in params dictionary with the input value
		else {
			params.setValue(k, executeLambda(paste(c(k, ";"), sep='')));
		}
	}	
	defineConstant("PARAMS", params);
	setSeed(seed);
	
	defineConstant("RECOMBINATION_RATE", 1e-8);
	rates = c(rep(c(RECOMBINATION_RATE, 0.5), num_linkage_groups - 1), RECOMBINATION_RATE);
	group_length = integerDiv(60000, num_linkage_groups);
	ends = NULL;
	for (i in seq(1, num_linkage_groups - 1)) {
		ends = c(ends, 20000 + group_length * i, 20000 + group_length * i + 1);
	}
	ends = c(ends, 99999);
	initializeRecombinationRate(rates, ends);


	// The genome is 100kbp long.
	// first 20k and last 2k segments are mutation-free in the forward-simulation because they are neutral loci. The neutral mutations can be overlayed on top of the tree sequence after the SLiM simulation. This is much faster than adding neutral mutation during the SLiM simulation.
	initializeMutationRate(c(0, MU, 0), ends=c(20000, 80000, 99999));
	// Now decide where to save output files and how to name them.
	// Note that quotation marks are removed from command line, so you should type something like -d OUTDIR=\'./newdir\' 
	if (!exists("OUTDIR")) defineConstant("OUTDIR", "./data");
	if (!exists("OUTNAME")) defineConstant("OUTNAME", "out");
	if (!fileExists(OUTDIR)) {
		createDirectory(OUTDIR);
	}
}

// Effects of m2 (QTN_B) and mu3 (QTM_CTmin) are accounted for later in fitnesEffect Callback. Before that step, they shouldn't change the fitness.
mutationEffect(m2) { return 1.0; }
mutationEffect(m3) { return 1.0; }

1 early() {
	sim.addSubpop("p1", N_POP); 
	// Setting up a log file that records values every 10 generations.
	log = community.createLogFile(OUTDIR+"/"+OUTNAME+".txt", logInterval=LOGINTERVAL);
	log.addCycle();
	log.addCustomColumn("Temp", "Temp;");	
	log.addMeanSDColumns("B", "p1.individuals.getValue(\"B\");");
	log.addMeanSDColumns("CTmin", "p1.individuals.getValue(\"CTmin\");");
	log.addCustomColumn("B_CTmin_cov", "cov(p1.individuals.getValue(\"B\"), p1.individuals.getValue(\"CTmin\"));");
	log.addMeanSDColumns("fitness", "p1.individuals.getValue(\"fitness\");");
	log.addMeanSDColumns("temp", "p1.individuals.getValue(\"temp\");");
}

early() {
	// Define seasonal sinusoidal temperature fluctuation
	// (Note acos(-1) = Pi)
	Temp_det = T_mean + T_amp * sin(sim.cycle / Num_gen_per_year * 2 * acos(-1));
	// add noise to Temp_det, accounting for across-generation fluctuation. "Temp" is a mean temperature for current generation, and later we will add within-generation fluctuation.
	defineGlobal("Temp", Temp_det + sigma_T_across_gen * rnorm(1));
	// if T is same for all individuals, we can add random noise sampled from normal distribution with standard deviation = sigma_T_within_gen, n_r (number of reproductive cycles) times.  
	if (T_same_for_all_individuals) {
		defineGlobal("temp", Temp + rnorm(n_r) * sigma_T_within_gen);
	}

}

fitnessEffect() {
	// Environmental factor is drawn from a normal distribution with zero mean, variance defined at the beginning of this script. Draw 2, one affects B, the other affects CTmin
	epsilon = rnorm(2, mean = 0, sd = sqrt(ENV_var));
	// B and CTmin of each individual is defined by the sum of effect sizes of QTN_B and QTN_CTmin.
	B = B_WT + individual.sumOfMutationsOfType(m2) + epsilon[0];
	CTmin = CTmin_WT + individual.sumOfMutationsOfType(m3) + epsilon[1];

	// Tag individuals with B and CTmin
	individual.setValue("B", B);
	individual.setValue("CTmin", CTmin);
	
	// If individuals are allowed to experience different temperature from each other, we define temperature series for n_r reproductive cycle in this Callback that is called separately for each individual.
	if (!T_same_for_all_individuals) {
		temp = Temp + rnorm(n_r) * sigma_T_within_gen;
		}
		individual.setValue("temp", temp);
	
	// During burn-in period, everyone has fitness = 1, regardless of their genotype.
	if (sim.cycle <= BURNIN){
		individual.setValue("fitness", 1.);
		return 1.;
		}
	// after burn-in, fitness is affected by TPC and temp.  
	else {
		// overall_fitness is a custom function defined at the end of this cript that returns a list of n_r instantaneous fitness's.
		lifetime_fitness_list = overall_fitness(temp, individual, Recovery);
		// The mean of n_r instantaneous fitness is used for selection step.
		lifetime_fitness = mean(lifetime_fitness_list);
		individual.setValue("fitness", lifetime_fitness);
		return lifetime_fitness;
		}
}

// This block can be commented out. Its purpose is to monitor B, CTmin and fitness when testing this script in SLiMgui.
seq(10, RUNTIME, 2) late() {
//	catn(sim.cycle);
	Bs = p1.individuals.getValue("B");
	meanB = mean(Bs);
	varB = var(Bs);
	
	CTmins = p1.individuals.getValue("CTmin");
	meanCTmin = mean(CTmins);
	varCTmin = var(CTmins);
	// Topt = CTmin + 2/3 * B for this TPC model
	meanTopt = mean(CTmins + 2/3 * Bs);
	varTopt = var(CTmins + 2/3 * Bs);
	catn("mean B = " + meanB);
	catn("var B = " + varB);
	catn("mean CTmin = " + meanCTmin);
	catn("var CTmin = " + varCTmin);
	catn("Temp = " + Temp);
	catn("mean Topt = " + meanTopt);
	catn("var Topt = " + varTopt);
	catn("mean fitness = " + mean(p1.individuals.getValue("fitness")));
}

// Finish simulation when we reach RUNTIME + 1 generation.
RUNTIME+1 late() {
	// add final B and CTmin of current population to the metadata
	PARAMS.setValue("Bs_final", p1.individuals.getValue("B"));
	PARAMS.setValue("CTmins_final", p1.individuals.getValue("CTmin"));
	
	// save tree sequence
	sim.treeSeqOutput(OUTDIR+"/"+OUTNAME+".trees", metadata = PARAMS);
	sim.simulationFinished();
}


// TPC component of fitness where fitness is normalized to 1 when temperature = Topt. We use Deutsch's model that has fitness rise as Gaussian below Topt and fall more rapidly past Topt (parabolic) and stays at zero from CTmax and above.
function(float)relative_fitness(float temp, float CTmin, float B) {
	Topt = CTmin + 2 / 3 * B;
	CTmax = CTmin + B;
	w_TPC = asFloat(temp <= Topt) * exp(-((3 * temp - 3 * CTmin - 2 * B) / B)^2) + asFloat(temp <= CTmax) * asFloat(temp > CTmin + 2 / 3 * B) * (1 - ((3 * temp - 3 * CTmin - 2 * B) / B)^2);
	return w_TPC;
}

// overall fitness is TPC_component multiplied by other fitness components that account for physiological constraints from extreme values of B, CTmin, or CTmax. 
// temp is a list of temperature at each reproductive cycle, and the output overall_fitness is a list of instantaneous fitness with the same shape.
function (float)overall_fitness(float temp, object<Individual>$ ind, logical recovery) {
	CTmin = ind.getValue("CTmin");
	B = ind.getValue("B");
	CTmax = CTmin + B;
	// logistic_B is close to 1 if B << B_critical  - DeltaB, 0 if B >> B_critical + DeltaB
	logistic_B = 1 / (1 + exp((B - B_critical) / DeltaB));
	// logistic_CTmin is close to 1 if CTmin >> CTmin_critical+DeltaCTmin, close to 0 if CTmin << CTmin_critical-DeltaCTmin
	logistic_CTmin = 1 / (1 + exp((-CTmin + CTmin_critical) / DeltaCTmin));
	// logistic_CTmax is close to 1 if CTmax << CTmax_critical-DeltaCTmax, close to 0 if CTmax >> CTmax_critical-DeltaCTmax
	logistic_CTmax = 1 / (1 + exp((CTmax - CTmax_critical) / DeltaCTmax));
	// TPC component (home-away relative fitness)
	// when using "recovery model", TPC component of each reproductive cycle can be simply calculated from the relative_fitness function from before.
	if (recovery){	
		tpc = relative_fitness(temp, CTmin, B);
		}
	// for no-recovery model, if at some reproductive cycle, temperature exceeds CTmax, it stops reproducing from that point, and TPC component should be zero for the rest of the generation.
	else {
		alive = T;
		tpc = c();
		for (t in temp){
			// asFloat(alive) = 0 if alive = F, making tpc zero, and asFloat(alive) = 1 if alive = T, making tpc equal to tpc_component given by relative_fitness function from before.
			tpc = c(tpc, asFloat(alive) * relative_fitness(t, CTmin, B));
			if (t > CTmax){
				alive = F;
			}
		}
	}
	// get overall fitness by multiplying all components together
	fitness = logistic_CTmin * logistic_B * logistic_CTmax * tpc;
	return fitness;
}
